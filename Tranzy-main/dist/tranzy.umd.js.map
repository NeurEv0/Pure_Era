{"version":3,"file":"tranzy.umd.js","sources":["../src/tranzy.js"],"sourcesContent":["/**\n * Tranzy.js - 专业的网页国际化解决方案 | JavaScript自动翻译库\n *\n * 主要功能：\n * 1. 自动检测DOM变化并翻译新增内容\n * 2. 支持批量翻译和缓存机制\n * 3. 提供灵活的配置选项和钩子函数\n * 4. 支持手动翻译词典和术语处理\n * 5. 内置微软翻译API实现\n *\n * 使用方式：\n * 1. 直接使用翻译功能：\n *    import { translateText } from 'tranzy';\n *    const result = await translateText(['Hello'], 'zh', 'en');\n *\n * 2. 使用页面翻译功能：\n *    import Tranzy from 'tranzy';\n *    const tranzy = new Tranzy({\n *      toLang: 'zh',\n *      fromLang: 'en'\n *    });\n *    await tranzy.translatePage();\n *\n * @author Fts Cloud <ftsuperb@vip.qq.com>\n * @license MIT\n * @repository https://github.com/FtsCloud/Tranzy\n * @copyright Copyright (c) 2023-present Fts Cloud\n */\n\n// 默认忽略的选择器列表，这些元素及其内容不会被翻译\nconst DEFAULT_IGNORE_SELECTORS = [\n  'style',            // 样式标签\n  'script',           // 脚本标签\n  'noscript',         // 无脚本标签\n  'kbd',              // 键盘输入标签\n  'code',             // 代码标签\n  'pre',              // 预格式化文本标签\n  'input',            // 输入框\n  'textarea',         // 文本域\n  '[contenteditable=\"true\"]', // 可编辑元素\n  '.tranzy-ignore'    // 自定义忽略类\n];\n\n// 默认配置选项\nconst DEFAULT_CONFIG = {\n  toLang: navigator.language || '',    // 目标语言，默认从浏览器语言设置获取\n  fromLang: '',                        // 源语言，如：'en'\n  ignore: [],                          // 自定义忽略选择器列表\n  force: [],                           // 强制翻译选择器列表\n  doneClass: 'tranzy-done',            // 已翻译元素的标记类\n  pendingClass: 'tranzy-pending',      // 正在翻译中的元素标记类\n  translateFn: translateText,          // 默认使用translateText函数\n  manualDict: {},                      // 手动翻译词典\n  beforeTranslate: null,               // 翻译开始前的钩子\n  afterTranslate: null,                // 翻译结束后的钩子\n};\n\n/**\n * 翻译缓存管理器\n * 使用IndexedDB存储翻译结果，提高性能并减少API调用\n */\nclass TranslationCache {\n  /**\n   * 创建TranslationCache实例\n   * @param {string} toLang - 目标语言代码\n   * @param {string} [fromLang=''] - 源语言代码\n   */\n  constructor(toLang, fromLang = '') {\n    this.dbName = `tranzy-${toLang}${fromLang ? '-' + fromLang : ''}`; // 基于语言对的数据库名称\n    this.storeName = 'translations';    // 存储对象名称\n    this.db = null;                     // 数据库实例\n    this.initPromise = this._initDatabase(); // 初始化Promise\n  }\n\n  /**\n   * 生成字符串哈希值\n   * 使用FNV-1a哈希算法，生成base36编码的短哈希值\n   * @param {string} str - 需要哈希的字符串\n   * @returns {string} - base36编码的哈希值\n   */\n  _generateHash(str) {\n    let hash = 2166136261;\n    for (let i = 0; i < str.length; i++) {\n      hash ^= str.charCodeAt(i);\n      hash *= 16777619;\n    }\n    return hash.toString(36);\n  }\n\n  /**\n   * 初始化IndexedDB数据库\n   * 创建数据库和存储对象，处理版本升级\n   * @returns {Promise} - 初始化完成的Promise\n   */\n  async _initDatabase() {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, 1);\n\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName, {keyPath: 'id'});\n        }\n      };\n\n      request.onsuccess = (event) => {\n        this.db = event.target.result;\n        resolve();\n      };\n\n      request.onerror = (event) => {\n        console.error(`Tranzy: Failed to initialize cache database / 初始化缓存数据库失败: ${this.dbName}`, event.target.error);\n        reject(event.target.error);\n      };\n    });\n  }\n\n  /**\n   * 获取缓存的翻译结果\n   * @param {string} text - 原文\n   * @returns {Promise<string|null>} - 缓存的翻译结果或null\n   */\n  async get(text) {\n    await this.initPromise;\n    // 只对文本本身进行哈希\n    const id = this._generateHash(text);\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve(null);\n        return;\n      }\n\n      const transaction = this.db.transaction(this.storeName, 'readonly');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.get(id);\n\n      request.onsuccess = (event) => {\n        resolve(event.target.result?.value || null);\n      };\n\n      request.onerror = () => {\n        resolve(null);\n      };\n    });\n  }\n\n  /**\n   * 设置翻译结果到缓存\n   * @param {string} text - 原文\n   * @param {string} translation - 翻译结果\n   * @returns {Promise<void>}\n   */\n  async set(text, translation) {\n    await this.initPromise;\n    // 只对文本本身进行哈希\n    const id = this._generateHash(text);\n\n    return new Promise((resolve) => {\n      if (!this.db) {\n        resolve();\n        return;\n      }\n\n      const transaction = this.db.transaction(this.storeName, 'readwrite');\n      const store = transaction.objectStore(this.storeName);\n      const request = store.put({\n        id,\n        value: translation\n      });\n\n      request.onsuccess = () => {\n        resolve();\n      };\n\n      request.onerror = () => {\n        resolve();\n      };\n    });\n  }\n\n  /**\n   * 批量设置翻译结果到缓存\n   * @param {string[]} texts - 原文数组\n   * @param {string[]} translations - 翻译结果数组\n   * @returns {Promise<void>}\n   */\n  async setBatch(texts, translations) {\n    await this.initPromise;\n    await Promise.all(texts.map((text, index) => {\n      return this.set(text, translations[index]);\n    }));\n  }\n\n  /**\n   * 销毁实例，关闭数据库连接\n   */\n  destroy() {\n    if (this.db) {\n      this.db.close();\n      this.db = null;\n    }\n  }\n}\n\n/**\n * 从sessionStorage加载认证token\n * @returns {{token: string|null, timestamp: number}} - token和获取时间戳\n */\nfunction loadTokenFromSession() {\n  try {\n    const tokenData = sessionStorage.getItem('tranzy_auth_token');\n    if (tokenData) {\n      const {\n        token,\n        timestamp\n      } = JSON.parse(tokenData);\n      const now = Date.now();\n      // 如果token未过期，则使用缓存的token\n      if (token && (now - timestamp) < 10 * 60 * 1000) {\n        return {\n          token,\n          timestamp\n        };\n      }\n      // token已过期，清除缓存\n      clearTokenFromSession();\n    }\n  } catch (error) {\n    console.error('Tranzy: Failed to load token from session / 从session加载token失败', error);\n    clearTokenFromSession();\n  }\n  return {\n    token: null,\n    timestamp: 0\n  };\n}\n\n/**\n * 保存认证token到sessionStorage\n * @param {string} token - 认证token\n * @param {number} timestamp - 获取时间戳\n */\nfunction saveTokenToSession(token, timestamp) {\n  try {\n    sessionStorage.setItem('tranzy_auth_token', JSON.stringify({\n      token,\n      timestamp\n    }));\n  } catch (error) {\n    console.error('Tranzy: Failed to save token to session / 保存token到session失败', error);\n  }\n}\n\n/**\n * 清除sessionStorage中的认证token\n */\nfunction clearTokenFromSession() {\n  try {\n    sessionStorage.removeItem('tranzy_auth_token');\n  } catch (error) {\n    console.error('Tranzy: Failed to clear token from session / 清除session中的token失败', error);\n  }\n}\n\n/**\n * 获取微软翻译API的认证token\n * 优先使用缓存的token，如果过期则重新获取\n * @returns {Promise<string>} - 认证token\n */\nasync function getAuthToken() {\n  const now = Date.now();\n  const {\n    token,\n    timestamp\n  } = loadTokenFromSession();\n\n  // 如果token获取时间小于10分钟，则直接返回\n  if (token && (now - timestamp) < 10 * 60 * 1000) {\n    return token;\n  }\n\n  try {\n    const response = await fetch('https://edge.microsoft.com/translate/auth', {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      }\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Failed to get Microsoft Translator authorization / 获取微软翻译授权失败: ${response.status} ${response.statusText}`);\n      return null;\n    }\n\n    const newToken = await response.text();\n    saveTokenToSession(newToken, now);\n\n    return newToken;\n  } catch (error) {\n    console.error('Tranzy: Failed to get Microsoft Translator authorization / 获取微软翻译授权失败', error);\n    clearTokenFromSession();\n    throw error;\n  }\n}\n\n/**\n * 调用微软翻译API进行翻译\n * @param {string[]} texts - 需要翻译的文本数组\n * @param {string} toLang - 目标语言代码\n * @param {string} [fromLang=''] - 源语言代码\n * @returns {Promise<string[]>} - 翻译结果数组\n */\nexport async function translateText(texts, toLang = navigator.language, fromLang = '') {\n  try {\n    // 过滤掉空文本和null值\n    const filteredTexts = texts.filter(text => text?.trim());\n\n    // 如果没有有效文本需要翻译，直接返回空数组\n    if (filteredTexts.length === 0) {\n      return [];\n    }\n\n    // 获取认证令牌\n    const token = await getAuthToken();\n\n    // 构建URL，只在设置了fromLang时添加from参数\n    const url = `https://api.cognitive.microsofttranslator.com/translate?${fromLang ? `from=${fromLang}&` : ''}to=${toLang}&api-version=3.0`\n\n    // 构建请求数据\n    const data = filteredTexts.map(text => ({Text: text}));\n\n    // 发送请求\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      },\n      body: JSON.stringify(data)\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Translation request failed / 翻译请求失败: ${response.status} ${response.statusText}`);\n      return texts; // 返回原文\n    }\n\n    // 处理响应\n    const result = await response.json();\n    return result.map(item => item.translations[0].text);\n  } catch (error) {\n    console.error('Tranzy: Translation request failed / 翻译请求失败', error);\n    throw error;\n  }\n}\n\n/**\n * 检测文本的语言\n * @param {string|string[]} texts - 需要检测语言的文本或文本数组\n * @returns {Promise<Array<{language: string, score: number, isTranslationSupported: boolean, isTransliterationSupported: boolean}>>} - 语言检测结果数组\n */\nexport async function detectLang(texts) {\n  try {\n    // 确保texts是数组\n    const textArray = Array.isArray(texts) ? texts : [texts];\n\n    // 过滤掉空文本和null值\n    const filteredTexts = textArray.filter(text => text?.trim());\n\n    // 如果没有有效文本需要检测，直接返回空数组\n    if (filteredTexts.length === 0) {\n      return [];\n    }\n\n    // 获取认证令牌\n    const token = await getAuthToken();\n\n    // 构建请求数据\n    const data = filteredTexts.map(text => ({Text: text}));\n\n    // 发送请求\n    const response = await fetch('https://api.cognitive.microsofttranslator.com/detect?api-version=3.0', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      },\n      body: JSON.stringify(data)\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Language detection request failed / 语言检测请求失败: ${response.status} ${response.statusText}`);\n      return []; // 返回空数组\n    }\n\n    // 处理响应\n    return await response.json();\n  } catch (error) {\n    console.error('Tranzy: Language detection failed / 语言检测失败', error);\n    throw error;\n  }\n}\n\n/**\n * 获取支持的语种列表\n * @param {string} [displayLang=''] - 用于显示语言名称的BCP 47语言代码，例如：'zh-CN'表示用简体中文显示语言名称\n * @returns {Promise<Object>} - 支持的语种列表，格式为 { languageCode: { name: string, nativeName: string, dir: string } }\n * 注意：所有语言代码均遵循BCP 47规范，例如：'zh-CN'、'en'、'ja'等\n */\nexport async function getSupportedLangs(displayLang = '') {\n  try {\n    // 构建请求头\n    const headers = {\n      'Content-Type': 'application/json'\n    };\n\n    // 如果指定了显示语言，添加到请求头\n    if (displayLang) {\n      headers['Accept-Language'] = displayLang;\n    }\n\n    // 发送请求\n    const response = await fetch('https://api.cognitive.microsofttranslator.com/languages?api-version=3.0', {\n      method: 'GET',\n      headers\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Failed to get supported languages / 获取支持语种列表失败: ${response.status} ${response.statusText}`);\n      return {}; // 返回空对象\n    }\n\n    // 处理响应，只返回translation部分\n    const result = await response.json();\n    return result.translation;\n  } catch (error) {\n    console.error('Tranzy: Failed to get supported languages / 获取支持语种列表失败', error);\n    throw error;\n  }\n}\n\n/**\n * 获取浏览器语言对应的支持语言代码\n * @returns {Promise<string>} - 支持的语言代码，例如：'zh-Hans'、'en'等\n * 注意：返回的语言代码遵循BCP 47规范\n */\nexport async function getBrowserLang() {\n  try {\n    // 获取浏览器语言\n    const browserLang = navigator.language;\n\n    // 获取认证令牌\n    const token = await getAuthToken();\n\n    // 发送请求，翻译空字符串\n    const response = await fetch(`https://api.cognitive.microsofttranslator.com/translate?to=${browserLang}&api-version=3.0`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      },\n      body: JSON.stringify([{Text: ''}])\n    });\n\n    if (!response.ok) {\n      console.error(`Tranzy: Failed to get browser language / 获取浏览器语言失败: ${response.status} ${response.statusText}`);\n      return navigator.language || 'en'; // 返回浏览器语言或默认英语\n    }\n\n    // 处理响应，获取支持的语言代码\n    const result = await response.json();\n    return result[0].translations[0].to;\n  } catch (error) {\n    console.error('Tranzy: Failed to get browser language / 获取浏览器语言失败', error);\n    throw error;\n  }\n}\n\n/**\n * Tranzy核心类\n * 提供页面翻译和DOM变化监听功能\n */\nexport class Translator {\n  /**\n   * 创建Translator实例\n   * @param {Object} config - 配置选项\n   * @param {string} config.toLang - 目标语言代码\n   * @param {string} [config.fromLang=''] - 源语言代码\n   * @param {string[]} [config.ignore=[]] - 忽略的选择器列表\n   * @param {string[]} [config.force=[]] - 强制翻译的选择器列表\n   * @param {string} [config.doneClass='tranzy-done'] - 已翻译元素的标记类\n   * @param {string} [config.pendingClass='tranzy-pending'] - 正在翻译中的元素标记类\n   * @param {Function} [config.translateFn=null] - 自定义翻译函数\n   * @param {Object} [config.manualDict={}] - 手动翻译词典\n   * @param {Function} [config.beforeTranslate=null] - 翻译开始前的钩子\n   * @param {Function} [config.afterTranslate=null] - 翻译结束后的钩子\n   */\n  constructor(config = {}) {\n    this.config = {...DEFAULT_CONFIG, ...config};\n\n    // 合并 all 配置到当前语言的配置中，当前语言的优先级更高\n    this.config.manualDict[this.config.toLang] = {\n      ...this.config.manualDict.all || {}, ...this.config.manualDict[this.config.toLang] || {}\n    };\n\n    // 标准化manualDict配置\n    const langDict = this.config.manualDict[this.config.toLang];\n    for (const term of Object.keys(langDict)) {\n      // 如果翻译值是字符串，转换为标准格式\n      if (typeof langDict[term] === 'string') {\n        langDict[term] = {\n          to: langDict[term],\n          standalone: true,\n          case: true\n        };\n      }\n    }\n\n    this.observer = null;\n    this.translationCache = new TranslationCache(this.config.toLang, this.config.fromLang);\n\n    // 合并并去重忽略选择器\n    this.config.ignore = [\n      ...new Set([\n        ...DEFAULT_IGNORE_SELECTORS,\n        ...(this.config.ignore || [])\n      ])\n    ];\n\n    // 确保强制翻译选择器是数组\n    this.config.force = this.config.force || [];\n\n    // 将数组选择器合并为字符串选择器，提高性能\n    this.forceSelectorString = this.config.force.length ? this.config.force.join(',') : '';\n    this.ignoreSelectorString = this.config.ignore.length ? this.config.ignore.join(',') : '';\n\n    // 初始化状态\n    this.isTranslating = false;         // 是否正在翻译\n    this.pendingElements = new Set();   // 待翻译元素集合\n    this.observerConfig = {             // 观察器配置\n      childList: true,                  // 观察子节点变化\n      subtree: true,                    // 观察后代节点变化\n      characterData: true               // 观察文本内容变化\n    };\n  }\n\n  /**\n   * 创建节点过滤器\n   * 用于TreeWalker，决定哪些节点需要被翻译\n   * @returns {Object} - 节点过滤器对象\n   */\n  _createNodeFilter() {\n    return {\n      acceptNode: function (node) {\n        // 跳过已翻译的元素，但允许检查其子元素\n        if (node.classList.contains(this.config.doneClass)) {\n          return NodeFilter.FILTER_SKIP;\n        }\n\n        // 优先级1：检查当前节点是否匹配force选择器\n        if (this.forceSelectorString && node.matches(this.forceSelectorString)) {\n          return NodeFilter.FILTER_ACCEPT;\n        }\n\n        // 优先级2：检查父节点是否匹配force选择器\n        if (this.forceSelectorString) {\n          let parent = node.parentNode;\n          while (parent && parent !== document) {\n            if (parent.matches(this.forceSelectorString)) {\n              return NodeFilter.FILTER_ACCEPT;\n            }\n            parent = parent.parentNode;\n          }\n        }\n\n        // 优先级3：检查子节点是否匹配force选择器\n        let hasForceChild = false;\n        if (this.forceSelectorString && node.children.length > 0) {\n          hasForceChild = node.querySelector(this.forceSelectorString);\n        }\n\n        // 优先级4：检查当前节点是否匹配ignore选择器\n        if (this.ignoreSelectorString && node.matches(this.ignoreSelectorString)) {\n          return hasForceChild ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n        }\n\n        // 优先级5：检查父节点是否匹配ignore选择器\n        if (this.ignoreSelectorString) {\n          let parent = node.parentNode;\n          while (parent && parent !== document) {\n            if (parent.matches(this.ignoreSelectorString)) {\n              return hasForceChild ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n            }\n            parent = parent.parentNode;\n          }\n        }\n\n        // 默认接受：如果以上所有条件都不满足，接受节点进行翻译\n        return NodeFilter.FILTER_ACCEPT;\n      }.bind(this)\n    };\n  }\n\n  /**\n   * 开始观察DOM变化\n   * @param {string} [root='body'] - 观察的根元素选择器\n   * @returns {Translator} - 当前实例，支持链式调用\n   */\n  startObserver(root = 'body') {\n    // 如果源语言和目标语言相同，跳过翻译过程\n    if (this.config.fromLang === this.config.toLang) {\n      return this;\n    }\n\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n\n    this.observer = new MutationObserver((mutations) => {\n      let shouldTranslate = false;\n      for (const mutation of mutations) {\n        // 处理新增节点\n        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n          for (const node of mutation.addedNodes) {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              // 使用TreeWalker遍历所有元素节点\n              const treeWalker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, this._createNodeFilter());\n\n              // 收集所有符合条件的元素\n              let currentNode = treeWalker.nextNode();\n              while (currentNode) {\n                this.pendingElements.add(currentNode);\n                shouldTranslate = true;\n                currentNode = treeWalker.nextNode();\n              }\n            }\n          }\n        }\n\n        // 处理文本变化\n        if (mutation.type === 'characterData') {\n          const node = mutation.target.parentNode;\n          if (node && node.nodeType === Node.ELEMENT_NODE) {\n            // 检查节点是否正在翻译中\n            if (node.classList.contains(this.config.pendingClass)) {\n              continue;\n            }\n\n            // 检查所有父元素，如果有任何父元素被忽略且不在强制翻译列表中，则跳过\n            let shouldSkip = false;\n            let parent = node;\n\n            while (parent) {\n              if (this.ignoreSelectorString && parent.matches(this.ignoreSelectorString) && !(this.forceSelectorString && parent.matches(this.forceSelectorString))) {\n                shouldSkip = true;\n                break;\n              }\n              parent = parent.parentNode;\n              if (!parent || parent === document) {\n                break;\n              }\n            }\n\n            if (!shouldSkip) {\n              this.pendingElements.add(node);\n              shouldTranslate = true;\n            }\n          }\n        }\n      }\n\n      if (shouldTranslate) {\n        // 直接翻译\n        this._translatePending();\n      }\n    });\n\n    this.observer.observe(document.querySelector(root), this.observerConfig);\n\n    return this;\n  }\n\n  /**\n   * 停止观察DOM变化\n   * @returns {Translator} - 当前实例，支持链式调用\n   */\n  stopObserver() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n    }\n\n    return this;\n  }\n\n  /**\n   * 翻译待处理元素\n   * @param {boolean} [again=false] - 是否是重复翻译\n   * @private\n   */\n  async _translatePending(again = false) {\n    if (this.pendingElements.size === 0 || this.isTranslating) {\n      return;\n    }\n\n    if (!again && typeof this.config.beforeTranslate === 'function') {\n      this.config.beforeTranslate();\n    }\n\n    this.isTranslating = true;\n\n    const elements = Array.from(this.pendingElements);\n    this.pendingElements.clear();\n\n    await this._translateElements(elements);\n\n    this.isTranslating = false;\n\n    // 检查是否有新的待处理元素\n    if (this.pendingElements.size > 0) {\n      this._translatePending(true);\n    } else {\n      if (typeof this.config.afterTranslate === 'function') {\n        this.config.afterTranslate();\n      }\n    }\n  }\n\n  /**\n   * 翻译整个页面\n   * @param {string} [root='body'] - 翻译的根元素选择器\n   * @returns {Promise<Translator>} - 当前实例，支持链式调用\n   */\n  async translatePage(root = 'body') {\n    // 如果源语言和目标语言相同，跳过翻译过程\n    if (this.isTranslating || this.config.fromLang === this.config.toLang) {\n      return this;\n    }\n\n    this.isTranslating = true;\n\n    // 临时停止观察器，避免翻译过程中触发更多的变化\n    const wasObserving = !!this.observer;\n    if (wasObserving) {\n      this.stopObserver();\n    }\n\n    // 执行beforeTranslate钩子\n    if (typeof this.config.beforeTranslate === 'function') {\n      this.config.beforeTranslate();\n    }\n\n    try {\n      // 使用TreeWalker获取所有需要翻译的元素\n      const elements = [];\n      const rootElement = document.querySelector(root);\n\n      // 创建TreeWalker，只显示元素节点\n      const treeWalker = document.createTreeWalker(rootElement, NodeFilter.SHOW_ELEMENT, this._createNodeFilter());\n\n      // 收集所有符合条件的元素\n      let node = treeWalker.nextNode();\n      while (node) {\n        elements.push(node);\n        node = treeWalker.nextNode();\n      }\n\n      await this._translateElements(elements);\n    } catch (error) {\n      console.error('Tranzy: Page translation failed / 页面翻译失败', error);\n    } finally {\n      // 执行afterTranslate钩子\n      if (typeof this.config.afterTranslate === 'function') {\n        this.config.afterTranslate();\n      }\n\n      this.isTranslating = false;\n\n      // 如果之前在观察，重新启动观察器\n      if (wasObserving) {\n        this.startObserver(root);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * 翻译元素数组\n   * @param {Element[]} elements - 需要翻译的元素数组\n   * @private\n   */\n  async _translateElements(elements) {\n    // 过滤出需要翻译的元素并保存文本\n    const validElements = [];\n    const elementsText = [];\n\n    for (const el of elements) {\n      const text = this._getElementText(el);\n      if (text) {\n        validElements.push(el);\n        elementsText.push(text);\n      }\n    }\n\n    if (validElements.length === 0) {\n      return;\n    }\n\n    // 批量处理元素\n    for (let i = 0; i < validElements.length; i += 100) {\n      const batchElements = validElements.slice(i, i + 100);\n      const batchTexts = elementsText.slice(i, i + 100);\n      await this._translateElementBatch(batchElements, batchTexts);\n    }\n  }\n\n  /**\n   * 检查文本中是否包含术语并拆分\n   * @param {string} text - 需要检查的文本\n   * @returns {string[]} - 拆分后的文本数组\n   * @private\n   */\n  _splitByTerms(text) {\n    const toLangDict = this.config.manualDict[this.config.toLang];\n    if (!toLangDict) {\n      return [text];\n    }\n\n    // 按长度降序排序术语，优先匹配最长的术语\n    const terms = Object.keys(toLangDict).sort((a, b) => b.length - a.length);\n\n    // 先检查是否有完全匹配的术语\n    for (const term of terms) {\n      const translation = toLangDict[term];\n      // 如果是独立匹配模式（默认为true）且文本完全等于术语\n      if ((translation.standalone !== false) && (translation.case === false ? text.toLowerCase() === term.toLowerCase() : text === term)) {\n        return [text];\n      }\n    }\n\n    // 如果没有完全匹配，且文本中没有包含任何术语，直接返回原文本\n    let containsAnyTerm = false;\n    for (const term of terms) {\n      const translation = toLangDict[term];\n      if (translation.case === false ? text.toLowerCase().includes(term.toLowerCase()) : text.includes(term)) {\n        containsAnyTerm = true;\n        break;\n      }\n    }\n\n    if (!containsAnyTerm) {\n      return [text];\n    }\n\n    // 拆分文本\n    const parts = [];\n    let currentText = text;\n\n    while (currentText.length > 0) {\n      let foundTerm = false;\n      for (const term of terms) {\n        const translation = toLangDict[term];\n        // 跳过需要独立匹配的术语\n        if (translation.standalone !== false) {\n          continue;\n        }\n\n        // 使用正则表达式匹配术语，根据case配置决定是否忽略大小写\n        const flags = translation.case === false ? 'gi' : 'g';\n        const termRegex = new RegExp(`\\\\b${term}\\\\b`, flags);\n        const match = termRegex.exec(currentText);\n\n        if (match) {\n          const index = match.index;\n          // 如果术语前面有文本，添加为一部分\n          if (index > 0) {\n            parts.push(currentText.substring(0, index));\n          }\n          // 添加术语\n          parts.push(term);\n          // 更新剩余文本\n          currentText = currentText.substring(index + term.length);\n          foundTerm = true;\n          break;\n        }\n      }\n      // 如果没有找到术语，将剩余文本作为一部分\n      if (!foundTerm) {\n        parts.push(currentText);\n        break;\n      }\n    }\n\n    return parts;\n  }\n\n  /**\n   * 获取元素的直接文本节点\n   * @param {Element} element - 需要获取文本节点的元素\n   * @returns {Array<{node: Text, text: string, leadingSpaces: string, trailingSpaces: string}>} - 文本节点信息数组\n   * @private\n   */\n  _getDirectTextNodes(element) {\n    const textNodes = [];\n    const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, {\n      acceptNode: (node) => {\n        if (node.parentNode !== element) {\n          return NodeFilter.FILTER_SKIP;\n        }\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    });\n\n    let node = treeWalker.nextNode();\n    while (node) {\n      const text = node.textContent;\n      const trimmed = text.trim();\n      if (trimmed) {\n        textNodes.push({\n          node,\n          text: trimmed,\n          leadingSpaces: text.match(/^\\s*/)[0],\n          trailingSpaces: text.match(/\\s*$/)[0]\n        });\n      }\n      node = treeWalker.nextNode();\n    }\n\n    return textNodes;\n  }\n\n  /**\n   * 批量翻译元素\n   * @param {Element[]} elements - 需要翻译的元素数组\n   * @param {string[]} textsArray - 对应的文本数组\n   * @private\n   */\n  async _translateElementBatch(elements, textsArray) {\n    // 收集需要翻译的文本和对应的元素\n    const elementsWithText = [];\n    const textsToTranslate = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      const text = textsArray[i];\n\n      // 将元素和文本添加到待处理列表\n      elementsWithText.push(element);\n      textsToTranslate.push(text);\n      // 标记元素为正在翻译状态，防止重复处理\n      element.classList.add(this.config.pendingClass);\n    }\n\n    if (textsToTranslate.length === 0) {\n      return;\n    }\n\n    // 创建元素到其直接文本节点的映射表\n    const nodeTextMap = new Map();\n\n    // 预处理每个元素，收集其直接文本节点\n    for (let i = 0; i < elementsWithText.length; i++) {\n      const element = elementsWithText[i];\n\n      // 如果元素包含子元素，需要单独处理每个文本节点\n      if (element.childElementCount > 0) {\n        // 收集元素的直接文本节点（不包含子元素的文本节点）\n        const textNodes = this._getDirectTextNodes(element);\n\n        // 如果元素包含多个文本节点，需要特殊处理\n        if (textNodes.length > 1) {\n          // 存储元素到其文本节点的映射关系，用于后续处理\n          nodeTextMap.set(element, textNodes);\n\n          // 为每个文本节点创建独立的翻译任务\n          for (const nodeInfo of textNodes) {\n            textsToTranslate.push(nodeInfo.text);\n            elementsWithText.push({\n              isTextNode: true,\n              nodeInfo\n            });\n          }\n\n          // 标记原始元素的翻译任务为跳过，因为已经为每个文本节点创建了独立任务\n          textsToTranslate[i] = null;\n        }\n      }\n    }\n\n    // 过滤掉被标记为跳过的元素和文本\n    const validElementTexts = elementsWithText.filter((_, i) => textsToTranslate[i] !== null);\n    const validTexts = textsToTranslate.filter(text => text !== null);\n\n    // 用术语替换处理每个文本\n    const termProcessedTexts = [];\n    const termMappings = new Map();\n\n    for (const text of validTexts) {\n      if (!text) {\n        continue;\n      }\n\n      // 检查文本中是否包含术语\n      const parts = this._splitByTerms(text);\n\n      // 如果被拆分，需要单独处理每个部分\n      if (parts.length > 1) {\n        termMappings.set(text, parts);\n        for (const part of parts) {\n          termProcessedTexts.push(part)\n        }\n      } else {\n        termProcessedTexts.push(text);\n      }\n    }\n\n    // 去重以减少翻译请求\n    const uniqueTextsToTranslate = [...new Set(termProcessedTexts)];\n\n    // 检查手动词典和缓存\n    const manualTranslations = {};\n    let textsToFetch = [];\n\n    for (const text of uniqueTextsToTranslate) {\n      // 检查手动词典\n      const toLangDict = this.config.manualDict[this.config.toLang];\n      const translation = toLangDict && (toLangDict[text] || (toLangDict[text.toLowerCase()]?.case === false ? toLangDict[text.toLowerCase()] : null));\n\n      if (translation) {\n        manualTranslations[text] = translation.to;\n      } else {\n        // 检查缓存\n        const cachedTranslation = await this.translationCache.get(text);\n        if (cachedTranslation) {\n          manualTranslations[text] = cachedTranslation;\n        } else {\n          textsToFetch.push(text);\n        }\n      }\n    }\n\n    textsToFetch = textsToFetch.filter(text => {\n      // 过滤掉只包含数字、空格、回车、特殊字符的文本\n      return /^(?![\\d\\s\\x21-\\x2F\\x3A-\\x40\\x5B-\\x60\\x7B-\\x7E\\r\\n，。？！；：“”‘’【】（）·《》…]*$).+/.test(text)\n    })\n\n    // 翻译未缓存的文本\n    if (textsToFetch.length > 0) {\n      try {\n        const apiResults = await this.config.translateFn(textsToFetch, this.config.toLang, this.config.fromLang);\n\n        // 更新缓存\n        await this.translationCache.setBatch(textsToFetch, apiResults);\n\n        // 合并翻译结果\n        for (let i = 0; i < textsToFetch.length; i++) {\n          manualTranslations[textsToFetch[i]] = apiResults[i];\n        }\n      } catch (error) {\n        console.error('Tranzy: Batch translation failed / 批量翻译失败', error);\n        for (const text of textsToFetch) {\n          manualTranslations[text] = text; // 错误时保持原文\n        }\n      }\n    }\n\n    // 构建最终翻译映射\n    const finalTranslations = new Map();\n\n    // 首先处理被术语拆分的文本\n    for (const [originalText, parts] of termMappings.entries()) {\n      const translatedParts = parts.map(part => manualTranslations[part] || part);\n      finalTranslations.set(originalText, translatedParts.join(''));\n    }\n\n    // 然后处理未被拆分的文本\n    for (const text of validTexts) {\n      if (!text || termMappings.has(text)) {\n        continue;\n      }\n      finalTranslations.set(text, manualTranslations[text] || text);\n    }\n\n    // 应用翻译结果\n    validElementTexts.forEach((element, index) => {\n      const originalText = validTexts[index];\n      if (!originalText) {\n        return;\n      }\n\n      const translatedText = finalTranslations.get(originalText);\n      if (!translatedText) {\n        return;\n      }\n\n      // 处理文本节点\n      if (element.isTextNode) {\n        const {\n          node,\n          leadingSpaces,\n          trailingSpaces\n        } = element.nodeInfo;\n        node.textContent = leadingSpaces + translatedText + trailingSpaces;\n\n        // 检查父元素是否已经处理完所有子节点\n        const parentElement = node.parentNode;\n        if (parentElement) {\n          // 等待下一个微任务，确保DOM更新完成\n          queueMicrotask(() => {\n            parentElement.classList.remove(this.config.pendingClass);\n            parentElement.classList.add(this.config.doneClass);\n          });\n        }\n      } else {\n        // 如果是简单元素(没有被分解为单独节点)，直接应用翻译\n        if (!nodeTextMap.has(element)) {\n          this._applyTranslation(element, originalText, translatedText);\n          // 等待下一个微任务，确保DOM更新完成\n          queueMicrotask(() => {\n            element.classList.remove(this.config.pendingClass);\n            element.classList.add(this.config.doneClass);\n          });\n        } else {\n          // 已经单独处理了各个文本节点，只需标记为已翻译\n          // 等待下一个微任务，确保DOM更新完成\n          queueMicrotask(() => {\n            element.classList.remove(this.config.pendingClass);\n            element.classList.add(this.config.doneClass);\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * 获取元素文本内容\n   * @param {Element} element - 需要获取文本的元素\n   * @returns {string|null} - 元素的文本内容，如果没有有效文本则返回null\n   * @private\n   */\n  _getElementText(element) {\n    // 使用TreeWalker遍历元素的所有文本节点\n    let textContent = '';\n    const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, {\n      acceptNode: (node) => {\n        // 只获取直接的文本节点，跳过深层元素内的文本\n        if (node.parentNode !== element) {\n          return NodeFilter.FILTER_SKIP;\n        }\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    });\n\n    let node = treeWalker.nextNode();\n    while (node) {\n      const text = node.textContent.trim();\n      if (text) {\n        textContent += `${text} `;\n      }\n      node = treeWalker.nextNode();\n    }\n\n    textContent = textContent.trim();\n\n    return textContent;\n  }\n\n  /**\n   * 应用翻译结果到元素\n   * @param {Element} element - 需要应用翻译的元素\n   * @param {string} originalText - 原始文本\n   * @param {string} translatedText - 翻译后的文本\n   * @private\n   */\n  _applyTranslation(element, originalText, translatedText) {\n    if (!translatedText || originalText === translatedText) {\n      return;\n    }\n\n    // 标记已翻译\n    element.classList.add(this.config.doneClass);\n\n    // 如果元素有子元素，只替换直接的文本节点\n    if (element.childElementCount > 0) {\n      // 1. 收集所有直接文本节点信息\n      const textNodes = this._getDirectTextNodes(element);\n\n      // 如果没有文本节点或只有一个文本节点，简单处理\n      if (textNodes.length === 0) {\n        return;\n      }\n      if (textNodes.length === 1) {\n        const {\n          node,\n          leadingSpaces,\n          trailingSpaces\n        } = textNodes[0];\n        node.textContent = leadingSpaces + translatedText + trailingSpaces;\n        return;\n      }\n\n      // 注意：多文本节点的情况已在_translateElementBatch中处理\n      // 这里作为备用方案，使用简单的按比例分配\n      const totalTextLength = textNodes.reduce((sum, item) => sum + item.text.length, 0);\n      let usedTranslationLength = 0;\n\n      textNodes.forEach((item, index) => {\n        const {\n          node,\n          text,\n          leadingSpaces,\n          trailingSpaces\n        } = item;\n        let nodeTranslation;\n\n        if (index === textNodes.length - 1) {\n          // 最后一个节点使用剩余的所有翻译文本\n          nodeTranslation = translatedText.substring(usedTranslationLength);\n        } else {\n          // 计算当前节点文本在原始完整文本中的占比\n          const ratio = text.length / totalTextLength;\n          // 根据比例计算应该分配的翻译文本长度\n          const translationLength = Math.round(translatedText.length * ratio);\n\n          // 从当前位置提取对应长度的翻译文本\n          nodeTranslation = translatedText.substring(usedTranslationLength, usedTranslationLength + translationLength);\n\n          // 更新已使用的翻译文本长度\n          usedTranslationLength += translationLength;\n        }\n\n        // 应用翻译结果到文本节点，保留原始空格\n        node.textContent = leadingSpaces + nodeTranslation + trailingSpaces;\n      });\n    } else {\n      // 如果没有子元素，保留原始文本中的空格\n      const leadingSpaces = element.textContent.match(/^\\s*/)[0];\n      const trailingSpaces = element.textContent.match(/\\s*$/)[0];\n      element.textContent = leadingSpaces + translatedText + trailingSpaces;\n    }\n  }\n\n  /**\n   * 销毁实例，释放资源\n   * @returns {Translator} - 当前实例，支持链式调用\n   */\n  destroy() {\n    // 停止DOM观察器\n    this.stopObserver();\n\n    // 清空待处理元素\n    this.pendingElements.clear();\n\n    // 关闭数据库连接\n    if (this.translationCache) {\n      this.translationCache.destroy();\n      this.translationCache = null;\n    }\n\n    // 重置状态\n    this.isTranslating = false;\n\n    return this;\n  }\n}\n\nexport default Translator; "],"names":["DEFAULT_IGNORE_SELECTORS","DEFAULT_CONFIG","toLang","navigator","language","fromLang","ignore","force","doneClass","pendingClass","translateFn","translateText","manualDict","beforeTranslate","afterTranslate","TranslationCache","constructor","this","dbName","storeName","db","initPromise","_initDatabase","_generateHash","str","hash","i","length","charCodeAt","toString","Promise","resolve","reject","request","indexedDB","open","onupgradeneeded","event","target","result","objectStoreNames","contains","createObjectStore","keyPath","onsuccess","onerror","console","error","get","text","id","transaction","objectStore","value","set","translation","put","setBatch","texts","translations","all","map","index","destroy","close","clearTokenFromSession","sessionStorage","removeItem","async","getAuthToken","now","Date","token","timestamp","tokenData","getItem","JSON","parse","loadTokenFromSession","response","fetch","method","headers","ok","status","statusText","newToken","setItem","stringify","saveTokenToSession","filteredTexts","filter","trim","url","data","Text","Authorization","body","json","item","Translator","config","langDict","term","Object","keys","to","standalone","case","observer","translationCache","Set","forceSelectorString","join","ignoreSelectorString","isTranslating","pendingElements","observerConfig","childList","subtree","characterData","_createNodeFilter","acceptNode","node","classList","NodeFilter","FILTER_SKIP","matches","FILTER_ACCEPT","parent","parentNode","document","hasForceChild","children","querySelector","FILTER_REJECT","bind","startObserver","root","disconnect","MutationObserver","mutations","shouldTranslate","mutation","type","addedNodes","nodeType","Node","ELEMENT_NODE","treeWalker","createTreeWalker","SHOW_ELEMENT","currentNode","nextNode","add","shouldSkip","_translatePending","observe","stopObserver","again","size","elements","Array","from","clear","_translateElements","translatePage","wasObserving","rootElement","push","validElements","elementsText","el","_getElementText","batchElements","slice","batchTexts","_translateElementBatch","_splitByTerms","toLangDict","terms","sort","a","b","toLowerCase","containsAnyTerm","includes","parts","currentText","foundTerm","flags","match","RegExp","exec","substring","_getDirectTextNodes","element","textNodes","SHOW_TEXT","textContent","trimmed","leadingSpaces","trailingSpaces","textsArray","elementsWithText","textsToTranslate","nodeTextMap","Map","childElementCount","nodeInfo","isTextNode","validElementTexts","_","validTexts","termProcessedTexts","termMappings","part","uniqueTextsToTranslate","manualTranslations","textsToFetch","cachedTranslation","test","apiResults","finalTranslations","originalText","entries","translatedParts","has","forEach","translatedText","parentElement","queueMicrotask","remove","_applyTranslation","totalTextLength","reduce","sum","usedTranslationLength","nodeTranslation","ratio","translationLength","Math","round","isArray","browserLang","displayLang"],"mappings":"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"}